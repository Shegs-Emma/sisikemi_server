// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: shippingAddress.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createShippingAddress = `-- name: CreateShippingAddress :one
INSERT INTO shipping_address (
    username,
    country,
    address,
    town,
    postal_code,
    landmark
) VALUES (
    $1, $2, $3, $4, $5, $6
)
RETURNING id, username, country, address, town, postal_code, landmark, created_at, expired_at
`

type CreateShippingAddressParams struct {
	Username   string      `json:"username"`
	Country    string      `json:"country"`
	Address    string      `json:"address"`
	Town       string      `json:"town"`
	PostalCode pgtype.Text `json:"postal_code"`
	Landmark   pgtype.Text `json:"landmark"`
}

func (q *Queries) CreateShippingAddress(ctx context.Context, arg CreateShippingAddressParams) (ShippingAddress, error) {
	row := q.db.QueryRow(ctx, createShippingAddress,
		arg.Username,
		arg.Country,
		arg.Address,
		arg.Town,
		arg.PostalCode,
		arg.Landmark,
	)
	var i ShippingAddress
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Country,
		&i.Address,
		&i.Town,
		&i.PostalCode,
		&i.Landmark,
		&i.CreatedAt,
		&i.ExpiredAt,
	)
	return i, err
}

const getShippingAddress = `-- name: GetShippingAddress :one
SELECT id, username, country, address, town, postal_code, landmark, created_at, expired_at FROM shipping_address
WHERE id = $1 LIMIT 1
FOR NO KEY UPDATE
`

func (q *Queries) GetShippingAddress(ctx context.Context, id int64) (ShippingAddress, error) {
	row := q.db.QueryRow(ctx, getShippingAddress, id)
	var i ShippingAddress
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Country,
		&i.Address,
		&i.Town,
		&i.PostalCode,
		&i.Landmark,
		&i.CreatedAt,
		&i.ExpiredAt,
	)
	return i, err
}

const getUserShippingAddresses = `-- name: GetUserShippingAddresses :many
SELECT id, username, country, address, town, postal_code, landmark, created_at, expired_at FROM shipping_address
WHERE username = $1
ORDER BY id
LIMIT $2
`

type GetUserShippingAddressesParams struct {
	Username string `json:"username"`
	Limit    int32  `json:"limit"`
}

func (q *Queries) GetUserShippingAddresses(ctx context.Context, arg GetUserShippingAddressesParams) ([]ShippingAddress, error) {
	rows, err := q.db.Query(ctx, getUserShippingAddresses, arg.Username, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ShippingAddress{}
	for rows.Next() {
		var i ShippingAddress
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.Country,
			&i.Address,
			&i.Town,
			&i.PostalCode,
			&i.Landmark,
			&i.CreatedAt,
			&i.ExpiredAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listShippingAddresses = `-- name: ListShippingAddresses :many
SELECT id, username, country, address, town, postal_code, landmark, created_at, expired_at FROM shipping_address
ORDER BY id
LIMIT $1
OFFSET $2
`

type ListShippingAddressesParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListShippingAddresses(ctx context.Context, arg ListShippingAddressesParams) ([]ShippingAddress, error) {
	rows, err := q.db.Query(ctx, listShippingAddresses, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ShippingAddress{}
	for rows.Next() {
		var i ShippingAddress
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.Country,
			&i.Address,
			&i.Town,
			&i.PostalCode,
			&i.Landmark,
			&i.CreatedAt,
			&i.ExpiredAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
