// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: products.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createProduct = `-- name: CreateProduct :one
INSERT INTO products (
    product_ref_no,
    product_name,
    product_description,
    product_code,
    price,
    sale_price,
    product_image_main,
    product_image_other_1,
    product_image_other_2,
    product_image_other_3,
    collection,
    quantity,
    color,
    size,
    status
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15
) RETURNING id, product_ref_no, product_name, product_description, product_code, price, sale_price, product_image_main, product_image_other_1, product_image_other_2, product_image_other_3, collection, quantity, color, size, status, last_updated_at, created_at
`

type CreateProductParams struct {
	ProductRefNo       string        `json:"product_ref_no"`
	ProductName        string        `json:"product_name"`
	ProductDescription string        `json:"product_description"`
	ProductCode        string        `json:"product_code"`
	Price              int64         `json:"price"`
	SalePrice          string        `json:"sale_price"`
	ProductImageMain   pgtype.Text   `json:"product_image_main"`
	ProductImageOther1 pgtype.Text   `json:"product_image_other_1"`
	ProductImageOther2 pgtype.Text   `json:"product_image_other_2"`
	ProductImageOther3 pgtype.Text   `json:"product_image_other_3"`
	Collection         int64         `json:"collection"`
	Quantity           int32         `json:"quantity"`
	Color              string        `json:"color"`
	Size               string        `json:"size"`
	Status             ProductStatus `json:"status"`
}

func (q *Queries) CreateProduct(ctx context.Context, arg CreateProductParams) (Product, error) {
	row := q.db.QueryRow(ctx, createProduct,
		arg.ProductRefNo,
		arg.ProductName,
		arg.ProductDescription,
		arg.ProductCode,
		arg.Price,
		arg.SalePrice,
		arg.ProductImageMain,
		arg.ProductImageOther1,
		arg.ProductImageOther2,
		arg.ProductImageOther3,
		arg.Collection,
		arg.Quantity,
		arg.Color,
		arg.Size,
		arg.Status,
	)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.ProductRefNo,
		&i.ProductName,
		&i.ProductDescription,
		&i.ProductCode,
		&i.Price,
		&i.SalePrice,
		&i.ProductImageMain,
		&i.ProductImageOther1,
		&i.ProductImageOther2,
		&i.ProductImageOther3,
		&i.Collection,
		&i.Quantity,
		&i.Color,
		&i.Size,
		&i.Status,
		&i.LastUpdatedAt,
		&i.CreatedAt,
	)
	return i, err
}

const getProduct = `-- name: GetProduct :one
SELECT id, product_ref_no, product_name, product_description, product_code, price, sale_price, product_image_main, product_image_other_1, product_image_other_2, product_image_other_3, collection, quantity, color, size, status, last_updated_at, created_at FROM products
WHERE id = $1 LIMIT 1
FOR NO KEY UPDATE
`

func (q *Queries) GetProduct(ctx context.Context, id int64) (Product, error) {
	row := q.db.QueryRow(ctx, getProduct, id)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.ProductRefNo,
		&i.ProductName,
		&i.ProductDescription,
		&i.ProductCode,
		&i.Price,
		&i.SalePrice,
		&i.ProductImageMain,
		&i.ProductImageOther1,
		&i.ProductImageOther2,
		&i.ProductImageOther3,
		&i.Collection,
		&i.Quantity,
		&i.Color,
		&i.Size,
		&i.Status,
		&i.LastUpdatedAt,
		&i.CreatedAt,
	)
	return i, err
}

const listProducts = `-- name: ListProducts :many
SELECT id, product_ref_no, product_name, product_description, product_code, price, sale_price, product_image_main, product_image_other_1, product_image_other_2, product_image_other_3, collection, quantity, color, size, status, last_updated_at, created_at FROM products
ORDER BY id
LIMIT $1
OFFSET $2
`

type ListProductsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListProducts(ctx context.Context, arg ListProductsParams) ([]Product, error) {
	rows, err := q.db.Query(ctx, listProducts, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Product{}
	for rows.Next() {
		var i Product
		if err := rows.Scan(
			&i.ID,
			&i.ProductRefNo,
			&i.ProductName,
			&i.ProductDescription,
			&i.ProductCode,
			&i.Price,
			&i.SalePrice,
			&i.ProductImageMain,
			&i.ProductImageOther1,
			&i.ProductImageOther2,
			&i.ProductImageOther3,
			&i.Collection,
			&i.Quantity,
			&i.Color,
			&i.Size,
			&i.Status,
			&i.LastUpdatedAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateProduct = `-- name: UpdateProduct :one
UPDATE products
SET
  product_ref_no = COALESCE($1, product_ref_no),
  product_name = COALESCE($2, product_name),
  product_description = COALESCE($3, product_description),
  product_code = COALESCE($4, product_code),
  price = COALESCE($5, price),
  sale_price = COALESCE($6, sale_price),
  product_image_main = COALESCE($7, product_image_main),
  product_image_other_1 = COALESCE($8, product_image_other_1),
  product_image_other_2 = COALESCE($9, product_image_other_2),
   product_image_other_3 = COALESCE($10, product_image_other_3),
  collection = COALESCE($11, collection),
  quantity = COALESCE($12, quantity),
  color = COALESCE($13, color),
  size = COALESCE($14, size),
  status = COALESCE($15, status)
WHERE
  id = $16
RETURNING id, product_ref_no, product_name, product_description, product_code, price, sale_price, product_image_main, product_image_other_1, product_image_other_2, product_image_other_3, collection, quantity, color, size, status, last_updated_at, created_at
`

type UpdateProductParams struct {
	ProductRefNo       pgtype.Text       `json:"product_ref_no"`
	ProductName        pgtype.Text       `json:"product_name"`
	ProductDescription pgtype.Text       `json:"product_description"`
	ProductCode        pgtype.Text       `json:"product_code"`
	Price              pgtype.Int8       `json:"price"`
	SalePrice          pgtype.Text       `json:"sale_price"`
	ProductImageMain   pgtype.Text       `json:"product_image_main"`
	ProductImageOther1 pgtype.Text       `json:"product_image_other_1"`
	ProductImageOther2 pgtype.Text       `json:"product_image_other_2"`
	ProductImageOther3 pgtype.Text       `json:"product_image_other_3"`
	Collection         pgtype.Int8       `json:"collection"`
	Quantity           pgtype.Int4       `json:"quantity"`
	Color              pgtype.Text       `json:"color"`
	Size               pgtype.Text       `json:"size"`
	Status             NullProductStatus `json:"status"`
	ID                 int64             `json:"id"`
}

func (q *Queries) UpdateProduct(ctx context.Context, arg UpdateProductParams) (Product, error) {
	row := q.db.QueryRow(ctx, updateProduct,
		arg.ProductRefNo,
		arg.ProductName,
		arg.ProductDescription,
		arg.ProductCode,
		arg.Price,
		arg.SalePrice,
		arg.ProductImageMain,
		arg.ProductImageOther1,
		arg.ProductImageOther2,
		arg.ProductImageOther3,
		arg.Collection,
		arg.Quantity,
		arg.Color,
		arg.Size,
		arg.Status,
		arg.ID,
	)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.ProductRefNo,
		&i.ProductName,
		&i.ProductDescription,
		&i.ProductCode,
		&i.Price,
		&i.SalePrice,
		&i.ProductImageMain,
		&i.ProductImageOther1,
		&i.ProductImageOther2,
		&i.ProductImageOther3,
		&i.Collection,
		&i.Quantity,
		&i.Color,
		&i.Size,
		&i.Status,
		&i.LastUpdatedAt,
		&i.CreatedAt,
	)
	return i, err
}
